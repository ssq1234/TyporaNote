# 设计模式

## 一.单例模式

> **意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。
>
> **主要解决：**一个全局使用的类频繁地创建与销毁。
>
> **何时使用：**当您想控制实例数目，节省系统资源的时候

### 1.饿汉式(推荐 但可能会造成内存浪费)

> **是否 Lazy 初始化：**否
>
> **是否多线程安全：**是
>
> **实现难度：**易

> 不是懒加载 在类装载时就完成了初始化

#### (1).静态常量

> 在类装载时就完成了初始化 避免了线程同步问题
>
> 但是没有达到懒加载的目的 可能会造成内存浪费

```java
package singleton.hungry;
/**
 * 单例模式 饿汉式（静态常量）
 * @author 孙术强
 * @date 2021/2/4 14:38
 */
public class StaticFinal {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton{

     //构造器私有化 外部不能new
    private  Singleton(){

    }

     //本类内部创建对象
    private final static Singleton instance = new Singleton();

     //提供一个共有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}

```

#### (2).静态代码块

> 优缺点和静态常量一致 
>
> 只不过初始化放到了静态代码块里

```java
package singleton.hungry;

/**
 * 单例模式 饿汉式（静态代码块）
 * @author 孙术强
 * @date 2021/2/4 14:51
 */
public class StaticBlock {
    public static void main(String[] args) {
        Singleton02 singleton1 = Singleton02.getInstance();
        Singleton02 singleton2 = Singleton02.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton02{
    private final static Singleton02 instance;
    private int a;
    //构造器私有化 外部不能new
    private  Singleton02(){

    }
    //在静态代码块中创建对象
    static {
        instance = new Singleton02();
    }
    //本类内部创建对象


    //提供一个共有的静态方法，返回实例对象
    public static Singleton02 getInstance() {
        return instance;
    }
}


```

### 2.懒汉式

> 是懒加载

#### (1).线程不安全(不能用)

> 在多个线程中，如果两个线程同时进入了
>
> if(instance==null){
>             instance = new Singleton01();
>  }
>
> 就会产生多个实例  所以不建议使用

```java
package singleton.lazy;

/**
 * 饿汉式（线程不安全）
 * @author 孙术强
 * @date 2021/2/4 15:04
 */
public class ThreadUnsafe {
    public static void main(String[] args) {
        Singleton01 singleton1 = Singleton01.getInstance();
        Singleton01 singleton2 = Singleton01.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton01{
    private static Singleton01 instance;
    
    //构造器私有化 外部不能new
    private  Singleton01(){

    }

    

    //在使用到该对象时才创建对象
    public static Singleton01 getInstance() {
        if(instance==null){
            instance = new Singleton01();
        }
        return instance;
    }
}

```

#### (2).静态代码块(不能用)

> 仍旧是线程不安全的

```java
package singleton.lazy;

/**
 * 饿汉式（静态代码块）
 * @author 孙术强
 * @date 2021/2/4 15:14
 */
public class StaticBlock {
    public static void main(String[] args) {
        Singleton02 singleton1 = Singleton02.getInstance();
        Singleton02 singleton2 = Singleton02.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton02{
    private final static Singleton02 instance;

    private Singleton02(){

    }
    static {
        instance = new Singleton02();
    }

    public static Singleton02 getInstance(){
        return instance;
    }
}


```

#### (3).线程安全(不推荐 性能低下)

> **是否 Lazy 初始化：**是
>
> **是否多线程安全：**是
>
> **实现难度：**易

> 对get方法加锁处理 但是执行get方法时都要进行同步  所以性能低下

```java
package singleton.lazy;


/**
 * 饿汉式（线程安全）
 * @author 孙术强
 * @date 2021/2/4 15:24
 */
public class ThreadSafe {
    public static void main(String[] args) {
        Singleton03 singleton1 = Singleton03.getInstance();
        Singleton03 singleton2 = Singleton03.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton03{
    private static Singleton03 instance;
    private Singleton03 (){}
    //进行加锁处理使线程安全
    public static synchronized Singleton03 getInstance() {
        if (instance == null) {
            instance = new Singleton03();
        }
        return instance;
    }
}

```

#### (4).双检锁/双重校验锁（推荐）

> **JDK 版本：**JDK1.5 起
>
> **是否 Lazy 初始化：**是
>
> **是否多线程安全：**是
>
> **实现难度：**较复杂

> 推荐 高性能

```java
package singleton.lazy;


/**
 * 饿汉式（双检锁/双重校验锁） 推荐
 * @author 孙术强
 * @date 2021/2/4 15:37
 */
public class DoubleThreadSafe {
    public static void main(String[] args) {
        Singleton04 singleton1 = Singleton04.getInstance();
        Singleton04 singleton2 = Singleton04.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}
class Singleton04{
    private static volatile Singleton04 instance;
    private Singleton04() {
        
    }
    //双重检查
    public static Singleton04 getInstance() {
        if(instance==null){
            synchronized (Singleton04.class){
                if (instance==null){
                    instance = new Singleton04();
                }
            }
        }
        return instance;
    }
}
```

### 3.静态内部类（推荐）

> **是否 Lazy 初始化：**是
>
> **是否多线程安全：**是
>
> **实现难度：**一般

> 线程安全 性能高 代码简单

```java
package singleton.staticinnerclass;


/**
 * 静态内部类 推荐使用
 * @author 孙术强
 * @date 2021/2/4 15:46
 */
public class StaticInner {
    public static void main(String[] args) {
        Singleton Singleton041 = Singleton.getInstance();
        Singleton Singleton042 = Singleton.getInstance();
        System.out.println(Singleton041 == Singleton042);
        System.out.println(Singleton041.hashCode() == Singleton042.hashCode());
    }
}

class Singleton{
    private static class Singleton04Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton (){}
    public static final Singleton getInstance() {
        return Singleton04Holder.INSTANCE;
    }
}

```

### 4.枚举（推荐）

> **JDK 版本：**JDK1.5 起
>
> **是否 Lazy 初始化：**否
>
> **是否多线程安全：**是
>
> **实现难度：**易

> 涉及到反序列化创建对象时 建议使用

```java
package singleton._enum;

/**
 * 单例模式 枚举实现
 * @author 孙术强
 * @date 2021/2/4 15:52
 */
public class Enum {
    public static void main(String[] args) {
        Singleton singleton = Singleton.INSTANCE;
        Singleton singleton1 = Singleton.INSTANCE;
        System.out.println(singleton==singleton1);
        System.out.println(singleton.hashCode()==singleton1.hashCode());
    }
}

enum Singleton{
    INSTANCE;
}
```

## 二.工厂模式

### 1.简单工厂模式

> 定义了一个创建对象的类，类中封装了实例化对象的行为

#### (1).反例

> 违反了设计模式的ocp原则，即对扩展开放，对修改关闭
>
> 当新增加一个Pizza的子类，就要对订单类OrderPizza进行修改,**违反了对修改关闭**

```java
package factory.simplefactory.bad.order;
/**
 * 发出订购
 * @author 孙术强
 * @date 2021/2/8 11:11
 */
public class PizzaStore {
    public static void main(String[] args) {
        new OrderPizza();
    }
}
```

```java
package factory.simplefactory.bad.order;

import factory.simplefactory.bad.pizza.CheessPizza;
import factory.simplefactory.bad.pizza.GreekPizza;
import factory.simplefactory.bad.pizza.Pizza;

/**
 * 订购pizza
 * @author 孙术强
 * @date 2021/2/8 11:03
 */
public class OrderPizza {
    //构造器
    public OrderPizza() {
        Pizza pizza = null;
        String orderType; //订购pizza的类型
        orderType = getType();
        if (orderType.equals("greek")) {
            pizza = new GreekPizza();
            pizza.setName("greek");
        } else if (orderType.equals("cheese")) {
            pizza = new CheessPizza();
            pizza.setName("cheese");
        }
        assert pizza != null;
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
    }
    //获取pizza种类
    private String getType() {
        return "cheese";
    }
}
```

```java
package factory.simplefactory.bad.pizza;
/**
 * pizza的父类
 * @author 孙术强
 * @date 2021/2/8 10:56
 */
public abstract class Pizza {
    protected String name; //名字
    public abstract void prepare(); //准备原材料 不同的pizza是不一样的 因此我们把它做成抽象方法
    //烘烤
    public void bake(){
        System.out.println(name+"baking;");
    }
    //切割
    public void cut(){
        System.out.println(name+"cutting;");
    }
    //打包
    public void box(){
        System.out.println(name+"boxing;");
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package factory.simplefactory.bad.pizza;
/**
 * cheesspizza
 * @author 孙术强
 * @date 2021/2/8 11:00
 */
public class CheessPizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println("给奶酪pizza，准备原材料");
    }
}
```

```java
package factory.simplefactory.bad.pizza;
/**
 * greekpizza
 * @author 孙术强
 * @date 2021/2/8 11:02
 */
public class GreekPizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println("给希腊pizza，准备原材料");
    }
}
```

#### (2).正确

> 创建一个工厂SimpleFactory来获取对象，如果徐要修改，只需要在工厂SimpleFactory修改

```java
package factory.simplefactory.good.order;
import factory.simplefactory.good.pizza.CheessPizza;
import factory.simplefactory.good.pizza.GreekPizza;
import factory.simplefactory.good.pizza.Pizza;
/**
 * 工厂模式  简单工厂模式
 * 工厂用来获取对象
 * @author 孙术强
 * @date 2021/2/8 10:51
 */
public class SimpleFactory {
    public Pizza createPizza(String orderType){
        Pizza pizza = null;
        if (orderType.equals("greek")) {
            pizza = new GreekPizza();
            pizza.setName("greek");
        } else if (orderType.equals("cheese")) {
            pizza = new CheessPizza();
            pizza.setName("cheese");
        }
        return pizza;
    }
}
```

```java
package factory.simplefactory.good.order;
/**
 * 工厂模式  简单工厂模式
 * 发出订购
 * @author 孙术强
 * @date 2021/2/8 11:11
 */
public class PizzaStore {
    public static void main(String[] args) {
        new OrderPizza().setSimpleFactory();
    }
}
```

```java
package factory.simplefactory.good.order;
import factory.simplefactory.good.pizza.Pizza;
/**
 * 工厂模式  简单工厂模式
 * 订购pizza
 * @author 孙术强
 * @date 2021/2/8 11:03
 */
public class OrderPizza {
    SimpleFactory simpleFactory =new SimpleFactory();
    Pizza pizza = null;
    public void setSimpleFactory() {
        String orderType = getType();
        pizza = simpleFactory.createPizza(orderType); //从工厂获取对象
        if (pizza!=null){
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        }
        else {
            System.out.println("没有该类型");
        }
    }
    //获取pizza种类
    private String getType() {
        return "paa";
    }
}
```

```java
package factory.simplefactory.good.pizza;
/**
 * 工厂模式  简单工厂模式
 * pizza的父类
 * @author 孙术强
 * @date 2021/2/8 10:56
 */
public abstract class Pizza {
    protected String name; //名字
    public abstract void prepare(); //准备原材料 不同的pizza是不一样的 因此我们把它做成抽象方法
    //烘烤
    public void bake(){
        System.out.println(name+"baking;");
    }
    //切割
    public void cut(){
        System.out.println(name+"cutting;");
    }
    //打包
    public void box(){
        System.out.println(name+"boxing;");
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package factory.simplefactory.good.pizza;
/**
 * 工厂模式  简单工厂模式
 * pizza的父类
 * @author 孙术强
 * @date 2021/2/8 10:56
 */
public abstract class Pizza {
    protected String name; //名字
    public abstract void prepare(); //准备原材料 不同的pizza是不一样的 因此我们把它做成抽象方法
    //烘烤
    public void bake(){
        System.out.println(name+"baking;");
    }
    //切割
    public void cut(){
        System.out.println(name+"cutting;");
    }
    //打包
    public void box(){
        System.out.println(name+"boxing;");
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package factory.simplefactory.good.pizza;
/**
 * 工厂模式  简单工厂模式
 * cheesspizza
 * @author 孙术强
 * @date 2021/2/8 11:00
 */
public class CheessPizza extends Pizza {
    @Override
    public void prepare() {
        System.out.println("给奶酪pizza，准备原材料");
    }
}
```

```java
package factory.simplefactory.good.pizza;
/**
 * 工厂模式  简单工厂模式
 * greekpizza
 * @author 孙术强
 * @date 2021/2/8 11:02
 */
public class GreekPizza extends Pizza {
    @Override
    public void prepare() {
        System.out.println("给希腊pizza，准备原材料");
    }
}
```

### 2.工厂方法模式

> 定义了一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类

```java
package factory.factorymethod.pizza;

/**
 * 工厂模式  工厂方法模式
 * pizza的父类
 * @author 孙术强
 * @date 2021/2/8 10:56
 */
public abstract class Pizza {
    protected String name; //名字

    public abstract void prepare(); //准备原材料 不同的pizza是不一样的 因此我们把它做成抽象方法
    //烘烤
    public void bake(){
        System.out.println(name+"baking;");
    }
    //切割
    public void cut(){
        System.out.println(name+"cutting;");
    }
    //打包
    public void box(){
        System.out.println(name+"boxing;");
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package factory.factorymethod.pizza;

/**
 * 工厂模式  工厂方法模式
 * @author 孙术强
 * @date 2021/2/9 18:22
 */
public class LDPepperPizza extends Pizza{
    @Override
    public void prepare() {
        setName("伦敦的胡椒pizza");
        System.out.println("伦敦的胡椒pizza准备材料");
    }
}
```

```java
package factory.factorymethod.pizza;

/**
 * 工厂模式  工厂方法模式
 * @author 孙术强
 * @date 2021/2/9 18:23
 */
public class LDCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName("伦敦的奶酪");
        System.out.println("伦敦的奶酪pizza准备原材料");
    }
}
```

```java
package factory.factorymethod.pizza;

/**
 * 工厂模式  工厂方法模式
 * @author 孙术强
 * @date 2021/2/9 18:21
 */
public class BJPepperPizza extends Pizza{
    @Override
    public void prepare() {
        setName("北京的胡椒pizza");
        System.out.println("北京的胡椒pizza准备材料");
    }
}
```

```java
package factory.factorymethod.pizza;

/**
 * 工厂模式  工厂方法模式
 * @author 孙术强
 * @date 2021/2/9 18:20
 */
public class BJCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName("北京的奶酪pizza");
        System.out.println("北京的奶酪pizza准备原材料");
    }
}
```

```java
package factory.factorymethod.order;


import factory.factorymethod.pizza.Pizza;

/**
 * 工厂模式  工厂方法模式
 * 订购pizza
 * @author 孙术强
 * @date 2021/2/8 11:03
 */
public abstract class OrderPizza {
    //构造器
    public OrderPizza() {
        Pizza pizza = null;
        String orderType; // 订购pizza的类型
        orderType = getType();
        pizza = createPizza(orderType);  // 由工厂子类完成
        assert pizza != null;
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
    }
    // 定义一个抽象方法  让各各子类自己实现
    abstract Pizza createPizza(String orderType);

    //获取pizza种类
    private String getType() {
        return "pepper";
    }
}
```

```java
package factory.factorymethod.order;

import factory.factorymethod.pizza.LDCheesePizza;
import factory.factorymethod.pizza.LDPepperPizza;
import factory.factorymethod.pizza.Pizza;

/**
 * 工厂模式  工厂方法模式
 * @author 孙术强
 * @date 2021/2/9 18:32
 */
public class LDOrderPizza extends OrderPizza{
    @Override
    Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheesse")){
            pizza = new LDCheesePizza();
        }
        if (orderType.equals("pepper")){
            pizza = new LDPepperPizza();
        }
        return pizza;
    }
}
```

```java
package factory.factorymethod.order;

import factory.factorymethod.pizza.BJCheesePizza;
import factory.factorymethod.pizza.BJPepperPizza;
import factory.factorymethod.pizza.Pizza;

/**
 * 工厂模式  工厂方法模式
 * @author 孙术强
 * @date 2021/2/9 18:31
 */
public class BJOrderPizza extends OrderPizza{

    @Override
    Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheess")){
            pizza = new BJCheesePizza();
        }else if (orderType.equals("pepper")){
            pizza = new BJPepperPizza();
        }
        return pizza;
    }
}
```

```java
package factory.factorymethod.order;

/**
 * 工厂模式  工厂方法模式
 * @author 孙术强
 * @date 2021/2/9 18:36
 */
public class PizzaStore {
    public static void main(String[] args) {
        // 创建北京口味的各种Pizza
        new BJOrderPizza();
        // 创建伦敦口味的各种Pizza
        new LDOrderPizza();
    }
}
```

### 3.抽象工厂模式

> 将简单工厂和工厂方法的整合
>
> 从设计层面上看 抽象工厂就是对简单工厂的改进（进一步抽象）

```java
package factory.abstractfactory.pizza;

/**
 * 工厂模式  抽象工厂模式
 * pizza的父类
 * @author 孙术强
 * @date 2021/2/8 10:56
 */
public abstract class Pizza {
    protected String name; //名字

    public abstract void prepare(); //准备原材料 不同的pizza是不一样的 因此我们把它做成抽象方法
    //烘烤
    public void bake(){
        System.out.println(name+"baking;");
    }
    //切割
    public void cut(){
        System.out.println(name+"cutting;");
    }
    //打包
    public void box(){
        System.out.println(name+"boxing;");
    }

    public void setName(String name) {
        this.name = name;
    }
}

```

```java
package factory.abstractfactory.pizza;

/**
 * 工厂模式  抽象工厂模式
 * @author 孙术强
 * @date 2021/2/9 18:22
 */
public class LDPepperPizza extends Pizza {
    @Override
    public void prepare() {
        setName("伦敦的胡椒pizza");
        System.out.println("伦敦的胡椒pizza准备材料");
    }
}

```

```java
package factory.abstractfactory.pizza;

/**
 * 工厂模式  抽象工厂模式
 * @author 孙术强
 * @date 2021/2/9 18:23
 */
public class LDCheesePizza extends Pizza {
    @Override
    public void prepare() {
        setName("伦敦的奶酪");
        System.out.println("伦敦的奶酪pizza准备原材料");
    }
}

```

```java
package factory.abstractfactory.pizza;

/**
 * 工厂模式  抽象工厂模式
 * @author 孙术强
 * @date 2021/2/9 18:21
 */
public class BJPepperPizza extends Pizza {
    @Override
    public void prepare() {
        setName("北京的胡椒pizza");
        System.out.println("北京的胡椒pizza准备材料");
    }
}

```

```java
package factory.abstractfactory.pizza;

/**
 * 工厂模式  抽象工厂模式
 * @author 孙术强
 * @date 2021/2/9 18:20
 */
public class BJCheesePizza extends Pizza {
    @Override
    public void prepare() {
        setName("北京的奶酪pizza");
        System.out.println("北京的奶酪pizza准备原材料");
    }
}

```

```java
package factory.abstractfactory.order;

/**
 * 工厂模式  抽象工厂模式
 * @author 孙术强
 * @date 2021/2/13 13:47
 */
public class PizzaStore {
    public static void main(String[] args) {
        new OrderPizza(new BJFactory());
    }
}

```

```java
package factory.abstractfactory.order;

import factory.abstractfactory.pizza.Pizza;

/**
 * 工厂模式  抽象工厂模式
 * @author 孙术强
 * @date 2021/2/13 13:43
 */
public class OrderPizza {
    AbsFactory absFactory;
    public OrderPizza(AbsFactory absFactory){
        setAbsFactory(absFactory);
    }
    public void setAbsFactory(AbsFactory absFactory) {
        Pizza pizza = null;
        String orderType = getType();
        this.absFactory = absFactory;
        pizza = absFactory.createPizza(orderType);
        assert pizza != null;
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
    }

    //获取pizza种类
    private String getType() {
        return "pepper";
    }
}

```

```java
package factory.abstractfactory.order;

import factory.abstractfactory.pizza.Pizza;

/**
 * 工厂模式  抽象工厂模式
 * @author 孙术强
 * @date 2021/2/13 13:38
 */
public interface AbsFactory {
    Pizza createPizza(String orderType);
}

```

```java
package factory.abstractfactory.order;

import factory.abstractfactory.pizza.BJCheesePizza;
import factory.abstractfactory.pizza.BJPepperPizza;
import factory.abstractfactory.pizza.Pizza;

/**
 * 工厂模式  抽象工厂模式
 * @author 孙术强
 * @date 2021/2/13 13:39
 */
public class BJFactory implements AbsFactory{
    @Override
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheese")){
            pizza = new BJCheesePizza();
        }
        if(orderType.equals("pepper")){
            pizza = new BJPepperPizza();
        }
        return pizza;
    }
}

```

```java
package factory.abstractfactory.order;

import factory.abstractfactory.pizza.LDCheesePizza;
import factory.abstractfactory.pizza.LDPepperPizza;
import factory.abstractfactory.pizza.Pizza;

/**
 * 工厂模式  抽象工厂模式
 * @author 孙术强
 * @date 2021/2/13 13:39
 */
public class LDFactory implements AbsFactory{
    @Override
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheese")){
            pizza = new LDCheesePizza();
        }
        if(orderType.equals("pepper")){
            pizza = new LDPepperPizza();
        }
        return pizza;
    }
}

```

## 三.原型模式

### 1.克隆羊

> Spring工厂获取对象分为单例和原型（即克隆一个对象，属性相同，但却不是一个对象）

```java
package prototype;

/**
 * 原型模式 克隆羊
 * @author 孙术强
 * @date 2021/2/15 11:43
 */
public class Sheep implements Cloneable{
    private String name;
    private int age;
    private String color;

    public Sheep(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                '}';
    }

    // 克隆该实例 使用默认的克隆
    @Override
    protected Object clone(){
        Sheep sheep = null;
        try {
            sheep = (Sheep) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return sheep;
    }
}

```

```java
package prototype;

/**
 * 原型模式 克隆羊
 * @author 孙术强
 * @date 2021/2/15 11:49
 */
public class Client {
    public static void main(String[] args) {
        Sheep sheep = new Sheep("汤姆",1,"白色");
        Sheep sheep1 = (Sheep) sheep.clone();
        Sheep sheep2 = (Sheep) sheep.clone();
        System.out.println(sheep1);
        System.out.println(sheep2);
    }
}
```

### 2.浅拷贝

> 被克隆的对象内包含引用类型 == 克隆出来的对象内的引用  引用不会克隆出新的 这就是浅拷贝

> 克隆方式同上

### 3.深拷贝

> 两种方法实现深拷贝 克隆出的对象不论是不是引用都是全新的 推荐使用方式二序列化的方式

```java
package prototype.deepcopy;

import java.io.Serializable;

/**
 * 原型模式 深拷贝
 * @author 孙术强
 * @date 2021/2/16 12:52
 */
public class DeepClone implements Serializable,Cloneable {
    private static final long serialVersionUID = 1L;

    private String cloneName;

    private String CloneClass;

     // 构造器
    public DeepClone(String cloneName, String cloneClass) {
        this.cloneName = cloneName;
        CloneClass = cloneClass;
    }

     // 默认的克隆方法
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

```

```java
package prototype.deepcopy;

import java.io.*;

/**
 * 原型模式 深拷贝
 * @author 孙术强
 * @date 2021/2/16 12:54
 */
public class DeepProtoType implements Serializable,Cloneable {
    public String name;

    public DeepProtoType() {
        super();
    }

     // 引用类型
    public DeepClone deepClone;

     // 深拷贝 方式1 重写克隆方法
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object deep = null;
         // 完成对基本数据类型的克隆
        deep = super.clone();
         // 对引用类型进行单独处理
        DeepProtoType deepClone = (DeepProtoType) deep;
         // 克隆一份新的DeepClone对象
        deepClone.deepClone = (DeepClone) this.deepClone.clone();
        return deepClone;
    }

    // 深拷贝 方式2 通过对象序列化实现 推荐使用
    public Object deepClone(){

         // 创建流对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;
        try {
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this); // 当前对象以对象流的方式输出

             // 反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            DeepProtoType copy = (DeepProtoType) ois.readObject();
            return copy;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }finally {
            try{
                 // 关闭流
                assert bos != null;
                bos.close();
                assert oos != null;
                oos.close();
                assert bis != null;
                bis.close();
                assert ois != null;
                ois.close();
            }catch (Exception e){
                e.printStackTrace();
            }
        }
    }
}

```

```java
package prototype.deepcopy;

/**
 * 原型模式 深拷贝
 * @author 孙术强
 * @date 2021/2/16 13:03
 */
public class Client {
    public static void main(String[] args) throws CloneNotSupportedException {
        DeepProtoType deepProtoType = new DeepProtoType();
        deepProtoType.name = "宋江";
        deepProtoType.deepClone = new DeepClone("大牛","DeepClone");

         // 方式一完成深拷贝
        DeepProtoType clone = (DeepProtoType) deepProtoType.clone();
        System.out.println(deepProtoType.name == clone.name);
        System.out.println(deepProtoType.deepClone == clone.deepClone);

        // 方式二完成深拷贝 推荐使用
        DeepProtoType clone1 = (DeepProtoType) deepProtoType.deepClone();
        System.out.println(deepProtoType.name == clone1.name);
        System.out.println(deepProtoType.deepClone == clone1.deepClone);
    }
}

```

## 四.建造者模式

> 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

```java
package builder.builder;

/**
 * 抽象的建造者
 * @author 孙术强
 * @date 2021/2/17 12:05
 */
public abstract class HouseBuilder {
    protected House house = new House();

     // 将建造的流程写好 抽象的方法
    public abstract void buildBasic();
    public abstract void buildWalls();
    public abstract void buildRoof();
     // 建造好房子 将产品房子返回
    public House build(){
        return house;
    }
}
```

```java
package builder.builder;
/**
 * 产品
 * @author 孙术强
 * @date 2021/2/17 12:04
 */
public class House {
    private String basic;
    private String wall;
    private String roof;

    public String getBasic() {
        return basic;
    }

    public void setBasic(String basic) {
        this.basic = basic;
    }

    public String getWall() {
        return wall;
    }

    public void setWall(String wall) {
        this.wall = wall;
    }

    public String getRoof() {
        return roof;
    }

    public void setRoof(String roof) {
        this.roof = roof;
    }
}
```

```java
package builder.builder;

/**
 * 建造房子具体实例 普通房子
 * @author 孙术强
 * @date 2021/2/17 12:09
 */
public class CommonHouse extends HouseBuilder{
    @Override
    public void buildBasic() {
        System.out.println("普通房子打地基");
    }

    @Override
    public void buildWalls() {
        System.out.println("普通房子砌墙");
    }

    @Override
    public void buildRoof() {
        System.out.println("普通房子盖屋顶");
    }
}

```

```java
package builder.builder;

/**
 * 建造房子具体实例 高楼
 * @author 孙术强
 * @date 2021/2/17 12:10
 */
public class HighHouse extends HouseBuilder{
    @Override
    public void buildBasic() {
        System.out.println("高楼打地基");
    }

    @Override
    public void buildWalls() {
        System.out.println("高楼砌墙");
    }

    @Override
    public void buildRoof() {
        System.out.println("高楼建房顶");
    }
}
```

```java
package builder.builder;
/**
 * 指挥者
 * @author 孙术强
 * @date 2021/2/17 12:11
 */
public class HouseDirector {
    HouseBuilder houseBuilder = null;

     // 构造器传入
    public HouseDirector(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }
     // set方法传入
    public void setHouseBuilder(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

     // 处理建造房子的流程 交给指挥者
    public House constructHouse(){
        houseBuilder.buildBasic();
        houseBuilder.buildWalls();
        houseBuilder.buildRoof();
        return houseBuilder.house;
    }
}
```

```java
package builder.builder;
/**
 * @author 孙术强
 * @date 2021/2/17 12:15
 */
public class Client {
    public static void main(String[] args) {

         // 确定要改的房子类型 是一个普通房子
        CommonHouse commonHouse = new CommonHouse();
         // 创建指挥者 告诉他要盖普通房子
        HouseDirector houseDirector = new HouseDirector(commonHouse);
         // 指挥者指挥建造一个普通房子 返回
        House house = houseDirector.constructHouse();
    }
}
```

## 五.适配器模式

### 1.类适配器

> A->适配器->B

```java
package adapterpattern.classadapter;

/**
 * 220V源电压
 * @author 孙术强
 * @date 2021/2/18 12:28
 */
public class Voltage220V {
    public int output220V(){
        int src = 220;
        System.out.println("源电压="+src+"V");
        return src;
    }
}
```

```java
package adapterpattern.classadapter;

/**
 * 5v适配器
 * @author 孙术强
 * @date 2021/2/18 12:29
 */
public interface IVoltage5V {
    int outPut5V();
}
```

```java
package adapterpattern.classadapter;
/**
 * 继承220V 实现5V 把220转换为5v
 * @author 孙术强
 * @date 2021/2/18 12:30
 */
public class VoltageAdapter extends Voltage220V implements IVoltage5V{
    @Override
    public int outPut5V() {
        int src = output220V();
        return src / 44;
    }
}
```

```java
package adapterpattern.classadapter;

/**
 * 手机充电
 * @author 孙术强
 * @date 2021/2/18 12:32
 */
public class Phone {
     // 充电
    public void charging(IVoltage5V iVoltage5V){
        if (iVoltage5V.outPut5V() == 5){
            System.out.println("电压为5v 可以开始充电");
        }else {
            System.out.println("不可以充电");
        }
    }
}
```

```java
package adapterpattern.classadapter;

/**
 * 客户端
 * @author 孙术强
 * @date 2021/2/18 12:34
 */
public class Client {
    public static void main(String[] args) {
        System.out.println("类适配器模式");
        Phone phone = new Phone();
         // 直接使用5v适配器
        phone.charging(new VoltageAdapter());
    }
}
```

### 2.对象适配器

> 把类适配器当中的继承 变成了组合

```java
package adapterpattern.objectadapter;

/**
 * 220V源电压
 * @author 孙术强
 * @date 2021/2/18 12:28
 */
public class Voltage220V {
    public int output220V(){
        int src = 220;
        System.out.println("源电压="+src+"V");
        return src;
    }
}
```

```java
package adapterpattern.objectadapter;

/**
 * 5v适配器
 * @author 孙术强
 * @date 2021/2/18 12:29
 */
public interface IVoltage5V {
    int outPut5V();
}
```

```java
package adapterpattern.objectadapter;

/**
 * 组合220V 实现5V 把220转换为5v
 * @author 孙术强
 * @date 2021/2/18 12:30
 */
public class VoltageAdapter implements IVoltage5V {
    private Voltage220V voltage220V;

     // 通过构造器传入一个220v
    public VoltageAdapter(Voltage220V voltage220V) {
        this.voltage220V = voltage220V;
    }

    @Override
    public int outPut5V() {
        int src = voltage220V.output220V();
        return src / 44;
    }
}

```

```java
package adapterpattern.objectadapter;

/**
 * 手机充电
 * @author 孙术强
 * @date 2021/2/18 12:32
 */
public class Phone {
     // 充电
    public void charging(IVoltage5V iVoltage5V){
        if (iVoltage5V.outPut5V() == 5){
            System.out.println("电压为5v 可以开始充电");
        }else {
            System.out.println("不可以充电");
        }
    }
}
```

```java
package adapterpattern.objectadapter;

/**
 * 客户端
 * @author 孙术强
 * @date 2021/2/18 12:34
 */
public class Client {
    public static void main(String[] args) {
        System.out.println("对象适配器模式");
        Phone phone = new Phone();
         // 直接使用5v适配器
        phone.charging(new VoltageAdapter(new Voltage220V()));
    }
}
```

### 3.接口适配器

> 有时候要实现一个接口但有些方法是用不到的 就可以用一个抽象类先空实现接口 再重写能够使用到的接口

```java
package adapterpattern.interfaceadapter;

/**
 * @author 孙术强
 * @date 2021/2/18 12:56
 */
public interface Interface4 {
    void m1();
    void m2();
    void m3();
    void m4();
}
```

```java
package adapterpattern.interfaceadapter;

/**
 * @author 孙术强
 * @date 2021/2/18 12:57
 */
public abstract class AbsAdapter implements Interface4{
    @Override
    public void m1() {

    }

    @Override
    public void m2() {

    }

    @Override
    public void m3() {

    }

    @Override
    public void m4() {

    }
}
```

```java
package adapterpattern.interfaceadapter;

/**
 * 接口适配器模式
 * @author 孙术强
 * @date 2021/2/18 12:57
 */
public class Client {
    public static void main(String[] args) {
        new AbsAdapter(){
            @Override
            public void m1() {
                System.out.println("m1被重写使用了");
            }
        }.m1();
    }
}
```

## 六.桥接模式

**意图：**将抽象部分与实现部分分离，使它们都可以独立的变化。

**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

```java
package bridgepattern;

/**
 * 桥接模式
 * 品牌
 * @author 孙术强
 * @date 2021/2/20 12:34
 */
public interface Brand {
    void open();
    void close();
    void call();
}

```

```java
package bridgepattern;

/**
 * 桥接模式
 * @author 孙术强
 * @date 2021/2/20 12:42
 */
public class Client {
    public static void main(String[] args) {
        FoldedPhone foldedPhone = new FoldedPhone(new XiaoMi());

    }
}

```

```java
package bridgepattern;

/**
 * 桥接模式
 * 折叠手机
 * @author 孙术强
 * @date 2021/2/20 12:40
 */
public class FoldedPhone extends Phone{
    public FoldedPhone(Brand brand) {
        super(brand);
    }

    @Override
    protected void close() {
        super.close();
        System.out.println("折叠手机");
    }

    @Override
    protected void call() {
        super.call();
        System.out.println("折叠手机");
    }

    @Override
    public void open(){
        super.open();
        System.out.println("折叠手机");
    }
}

```

```java
package bridgepattern;

/**
 * 桥接模式
 * @author 孙术强
 * @date 2021/2/20 12:37
 */
public abstract class Phone {

     // 组合品牌 抽象类组合了品牌接口
    private Brand brand;

    public Phone(Brand brand) {
        this.brand = brand;
    }

     //
    protected void open(){
        brand.open();
    }
    protected void close(){
        brand.close();
    }
    protected void call(){
        brand.call();
    }
}

```

```java
package bridgepattern;

/**
 * 桥接模式
 * @author 孙术强
 * @date 2021/2/20 12:36
 */
public class Vivo implements Brand{
    @Override
    public void open() {
        System.out.println("vivo手机开机");
    }

    @Override
    public void close() {
        System.out.println("vivo手机关机");
    }

    @Override
    public void call() {
        System.out.println("vivo手机打电话");
    }
}

```

```java
package bridgepattern;

/**
 * 桥接模式
 * @author 孙术强
 * @date 2021/2/20 12:36
 */
public class XiaoMi implements Brand{
    @Override
    public void open() {
        System.out.println("小米手机开机");
    }

    @Override
    public void close() {
        System.out.println("小米手机关机");
    }

    @Override
    public void call() {
        System.out.println("小米手机打电话");
    }
}
```

## 七.装饰者模式

![image-20210221163919335](https://typora1-1304288279.cos.ap-beijing.myqcloud.com/image-20210221163919335.png)

```java
package decorator;

/**
 * 饮品抽象类
 * @author 孙术强
 * @date 2021/2/21 16:10
 */
public abstract class Drink {
    public String des; // 描述
    private float price = 0.0f; // 价格

    public abstract float cost();
    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }
}

```

```java
package decorator;

/**
 * 饮料咖啡
 * @author 孙术强
 * @date 2021/2/21 16:12
 */
public class Coffee extends Drink{
    @Override
    public float cost() {
        return super.getPrice();
    }
}

```

```java
package decorator;

/**
 * @author 孙术强
 * @date 2021/2/21 16:14
 */
public class LongBlack extends Coffee{
    public LongBlack() {
        setDes("美式咖啡");
        setPrice(5.0f);
    }
}

```

```java
package decorator;

/**
 * 装饰者
 * @author 孙术强
 * @date 2021/2/21 16:15
 */
public class Decorator extends Drink{
    public Decorator(Drink obj) {
        this.obj = obj;
    }

    private Drink obj;
    @Override
    public float cost() {
         // getprice 自己的价格
         // obj.cost() 咖啡的价格
        return getPrice()+obj.cost();
    }

    @Override
    public String getDes() {
         // super.des 自己的描述信息
         // super.getPrice() 自己的描述
         // obj.getDes() 咖啡的描述信息
        return des+" "+getPrice()+" && "+obj.getDes()+" ";
    }
}

```

```java
package decorator;

/**
 * 巧克力装饰者
 * @author 孙术强
 * @date 2021/2/21 16:20
 */
public class Chocolate extends Decorator{
    public Chocolate(Drink obj) {
        super(obj);
        setDes("巧克力");
        setPrice(3.0f);
    }

}

```

```java
package decorator;

/**牛奶装饰者
 * @author 孙术强
 * @date 2021/2/21 16:21
 */
public class Milk extends Decorator{
    public Milk(Drink obj) {
        super(obj);
        setDes("牛奶");
        setPrice(2.0f);
    }

}

```

```java
package decorator;

/**
 * 装饰者模式
 * @author 孙术强
 * @date 2021/2/21 16:22
 */
public class Client {
    public static void main(String[] args) {
         // 两份巧克力+一份牛奶的 LongBlack 咖啡

         // 先点咖啡
        Drink longBlack = new LongBlack();
        System.out.println("咖啡的价格"+longBlack.cost());
        System.out.println("描述："+longBlack.getDes());
         // 再点调料
        longBlack = new Milk(longBlack);
        System.out.println("加入一份牛奶价格"+longBlack.cost());
        System.out.println("加入一份牛奶描述："+longBlack.getDes());
        // 再点调料
        longBlack = new Chocolate(longBlack);
        System.out.println("加入一份牛奶加入一份巧克力价格"+longBlack.cost());
        System.out.println("加入一份牛奶加入一份巧克力描述："+longBlack.getDes());
        // 再点调料
        longBlack = new Chocolate(longBlack);
        System.out.println("加入一份牛奶加入两份巧克力价格"+longBlack.cost());
        System.out.println("加入一份牛奶加入两份巧克力描述："+longBlack.getDes());
    }
}

```

## 八.组合模式

![image-20210223165232441](https://typora1-1304288279.cos.ap-beijing.myqcloud.com/image-20210223165232441.png)

> HashMap用到了组合模式 HashMap组合了Node节点

```java
package composite;

/**
 * @author 孙术强
 * @date 2021/2/23 16:59
 */
public abstract class OrganizationComponent {

    private String name; // 名字

    private String des; // 描述

    protected void add(OrganizationComponent organizationComponent){
         // 默认实现
        throw new UnsupportedOperationException();
    }

    protected void remove(OrganizationComponent organizationComponent){
        // 默认实现
        throw new UnsupportedOperationException();
    }

    public abstract void print();

    public OrganizationComponent(String name, String des) {
        this.name = name;
        this.des = des;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }
}
```

```java
package composite;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 孙术强
 * @date 2021/2/23 17:03
 */
public class University extends OrganizationComponent{
    List<OrganizationComponent> list = new ArrayList<>();
    public University(String name, String des) {
        super(name, des);
    }

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        list.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        list.remove(organizationComponent);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }
     // 输出大学包含的学院
    @Override
    public void print() {
        System.out.println("---------"+getName()+"----------");
        for (OrganizationComponent organizationComponent : list) {
            organizationComponent.print();
        }
    }
}

```

```java
package composite;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 孙术强
 * @date 2021/2/23 17:08
 */
public class College extends OrganizationComponent{
    List<OrganizationComponent> list = new ArrayList<>();
    public College(String name, String des) {
        super(name, des);
    }

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        list.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        list.remove(organizationComponent);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }
    // 输出学院包含的系
    @Override
    public void print() {
        System.out.println("---------"+getName()+"----------");
        for (OrganizationComponent organizationComponent : list) {
            organizationComponent.print();
        }
    }
}

```

```java
package composite;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 孙术强
 * @date 2021/2/23 17:09
 */
public class Department extends OrganizationComponent{
    public Department(String name, String des) {
        super(name, des);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }
    // 输出学院包含的系
    @Override
    public void print() {
        System.out.println("---------"+getName()+"----------");
    }
}

```

```java
package composite;

/**
 * 组合模式
 * @author 孙术强
 * @date 2021/2/23 17:11
 */
public class Client {
    public static void main(String[] args) {
         // 从大到小创建对象
        OrganizationComponent university = new University("清华大学", "垃圾大学");
         // 创建学院
        OrganizationComponent college = new College("计算机学院", "计算机学院的描述");
        OrganizationComponent college1 = new College("信息工程学院", "信息工程学院的描述");
         // 创建系
        college.add(new Department("软件工程","软件工程不错"));
        college.add(new Department("网络工程","真垃圾"));
        college.add(new Department("计算机科学技术","真垃圾"));

        college1.add(new Department("通信工程","垃圾"));
        college1.add(new Department("信息工程","很垃圾"));

         // 将学院加入学校
        university.add(college);
        university.add(college1);

        university.print();
    }
}
```

## 九.外观模式

> Mybatis用到了外观模式

```java
package facadepattern;
/**
 * 外观模式
 * @author 孙术强
 * @date 2021/2/25 13:16
 */
public class Client {
    public static void main(String[] args) {
        HomeTheaterFacade homeTheaterFacade = new HomeTheaterFacade();
        homeTheaterFacade.ready();
        homeTheaterFacade.play();
        homeTheaterFacade.end();
    }
}
```

```java
package facadepattern;
/**
 * @author 孙术强
 * @date 2021/2/25 13:10
 */
public class HomeTheaterFacade {
    private TheaterLight theaterLight;
    private PopCorn popCorn;
    private Stereo stereo;
    private Projector projector;
    private Screen screen;
    private DVDPlayer dvdPlayer;

    public HomeTheaterFacade() {
        this.theaterLight = TheaterLight.getInstance();
        this.popCorn = PopCorn.getInstance();
        this.stereo = Stereo.getInstance();
        this.projector = Projector.getInstance();
        this.screen = Screen.getInstance();
        this.dvdPlayer = DVDPlayer.getInstance();
    }
    public void ready(){
        popCorn.on();
        popCorn.pop();
        screen.down();
        projector.on();
        dvdPlayer.on();
        theaterLight.off();
    }

    public void play(){
        dvdPlayer.play();
    }

    public void pause(){
        dvdPlayer.pause();
    }

    public void end(){
        popCorn.off();
        screen.up();
        projector.off();
        dvdPlayer.off();
        theaterLight.off();
    }
}
```

```java
package facadepattern;
/**
 * @author 孙术强
 * @date 2021/2/25 13:01
 */
public class DVDPlayer {
    private static DVDPlayer instance = new DVDPlayer();

    public static DVDPlayer getInstance() {
        return instance;
    }

    public void on(){
        System.out.println("DVD打开了");
    }
    public void off(){
        System.out.println("DVD关闭了");
    }
    public void play(){
        System.out.println("DVD正在播放");
    }
    public void pause(){
        System.out.println("DVD暂停了");
    }
}
```

```java
package facadepattern;
/**
 * @author 孙术强
 * @date 2021/2/25 13:03
 */
public class PopCorn {
    private static PopCorn instance = new PopCorn();

    public static PopCorn getInstance() {
        return instance;
    }
    public void on(){
        System.out.println("爆米花开启");
    }
    public void off(){
        System.out.println("爆米花关闭了");
    }
    public void pop(){
        System.out.println("正在出爆米花");
    }
}
```

```java
package facadepattern;
/**
 * @author 孙术强
 * @date 2021/2/25 13:05
 */
public class Projector {
    private static Projector instance = new Projector();

    public static Projector getInstance() {
        return instance;
    }
    public void on(){
        System.out.println("投影仪开启了");
    }
    public void off(){
        System.out.println("投影仪关闭了");
    }
    public void focus(){
        System.out.println("投影仪正在聚焦");
    }
}
```

```java
package facadepattern;
/**
 * @author 孙术强
 * @date 2021/2/25 13:06
 */
public class Screen {
    private static Screen instance = new Screen();

    public static Screen getInstance() {
        return instance;
    }
    public void up(){
        System.out.println("屏幕上升");
    }
    public void down(){
        System.out.println("屏幕下降");
    }
    public void pop(){
        System.out.println("正在出爆米花");
    }
}
```

```java
package facadepattern;
/**
 * @author 孙术强
 * @date 2021/2/25 13:07
 */
public class Stereo {
    private static Stereo instance = new Stereo();

    public static Stereo getInstance() {
        return instance;
    }
    public void on(){
        System.out.println("立体声开启");
    }
    public void off(){
        System.out.println("立体声关闭了");
    }
    public void up(){
        System.out.println("立体声调大");
    }
}
```

```java
package facadepattern;
/**
 * @author 孙术强
 * @date 2021/2/25 13:08
 */
public class TheaterLight {
    private static TheaterLight instance = new TheaterLight();

    public static TheaterLight getInstance() {
        return instance;
    }
    public void on(){
        System.out.println("灯光开启");
    }
    public void off(){
        System.out.println("灯光关闭了");
    }
    public void pop(){
        System.out.println("灯光调亮");
    }
}
```

## 十.享元模式

> 应用于  池   可以共享一些对象

```java
package flyweightpattern;

/**
 * 享元模式
 * @author 孙术强
 * @date 2021/3/3 16:15
 */
public class Client {
    public static void main(String[] args) {

         // 创建一个工厂类
        WebSiteFactory webSiteFactory = new WebSiteFactory();

        // 客户要一个以新闻形式发布的网站
        WebSite aNew = webSiteFactory.getWebSiteCategory("新闻");
        aNew.use(new User("tom"));

        // 客户要一个以博客形式发布的网站
        WebSite aBo = webSiteFactory.getWebSiteCategory("博客");
        aBo.use(new User("jack"));

        // 客户要一个以博客形式发布的网站
        WebSite aBo1 = webSiteFactory.getWebSiteCategory("博客");
        aBo1.use(new User("wsm"));

        // 池中一共有多少
        System.out.println(webSiteFactory.getWebSiteCount());
    }
}
```

```java
package flyweightpattern;

/**
 * @author 孙术强
 * @date 2021/3/3 16:08
 */
public class ConcreteWebSite extends WebSite{

    private String type = ""; // 网站发布的形式（类型）

    @Override
    public void use(User user) {
        System.out.println("网站的发布形式为"+type+"用户为"+user.getName());
    }

     // 构造器传入具体的网站形式
    public ConcreteWebSite(String type) {
        this.type = type;
    }
}

```

```java
package flyweightpattern;

/**
 * @author 孙术强
 * @date 2021/3/3 16:22
 */
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```

```java
package flyweightpattern;

/**
 * @author 孙术强
 * @date 2021/3/3 16:07
 */
public abstract class WebSite {

    public abstract void use(User user); // 抽象方法
}

```

```java
package flyweightpattern;

import java.util.HashMap;

/**
 * 网站工厂类，根据需求返回一个网站
 * @author 孙术强
 * @date 2021/3/3 16:10
 */
public class WebSiteFactory {

     // 集合 充当  ”池“  的作用
    private HashMap<String, ConcreteWebSite> pool = new HashMap<>();

     // 根据网站的类型，返回一个网站，如果没有就创建一个网站并放入到池中
    public WebSite getWebSiteCategory(String type){
        if (!pool.containsKey(type)){
             // 如果没有就创建一个

            pool.put(type,new ConcreteWebSite(type));
        }
        return pool.get(type);
    }

     // 池中有多少个实际的网站类型
    public int getWebSiteCount(){
        return pool.size();
    }
}
```

## 十一.代理模式

### 1.静态代理

> 静态代理随着被代理类的增多 接口和代理类都需要进行修改 所以修改很复杂

```java
package proxypattern;

/**
 * 静态代理
 * @author 孙术强
 * @date 2021/3/4 15:42
 */
public class Client {
    public static void main(String[] args) {
         // 创建目标对象
        TeacherDao teacherDao = new TeacherDao();
         // 创建代理对象
        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);

         // 使用
        teacherDaoProxy.teach();
    }
}
```

```java
package proxypattern;

/**
 * @author 孙术强
 * @date 2021/3/4 15:39
 */
public interface ITeacherDao {
    void teach();
}
```

```java
package proxypattern;

/**
 * @author 孙术强
 * @date 2021/3/4 15:40
 */
public class TeacherDao implements ITeacherDao{
    @Override
    public void teach() {
        System.out.println("老师授课中");
    }
}
```

```java
package proxypattern;

/**
 * 静态代理类
 * @author 孙术强
 * @date 2021/3/4 15:40
 */
public class TeacherDaoProxy implements ITeacherDao{
    private ITeacherDao target; // 目标对象 通过接口聚合

    public TeacherDaoProxy(ITeacherDao target) {
        this.target = target;
    }

    @Override
    public void teach() {
        System.out.println("代理开始");
        target.teach();
        System.out.println("代理结束");
    }
}
```

### 2.动态代理
# 设计模式

## 一.单例模式

> **意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。
>
> **主要解决：**一个全局使用的类频繁地创建与销毁。
>
> **何时使用：**当您想控制实例数目，节省系统资源的时候

### 1.饿汉式(推荐 但可能会造成内存浪费)

> **是否 Lazy 初始化：**否
>
> **是否多线程安全：**是
>
> **实现难度：**易

> 不是懒加载 在类装载时就完成了初始化

#### (1).静态常量

> 在类装载时就完成了初始化 避免了线程同步问题
>
> 但是没有达到懒加载的目的 可能会造成内存浪费

```java
package singleton.hungry;

/**
 * 单例模式 饿汉式（静态常量）
 * @author 孙术强
 * @date 2021/2/4 14:38
 */
public class StaticFinal {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}



class Singleton{

     //构造器私有化 外部不能new
    private  Singleton(){

    }

     //本类内部创建对象
    private final static Singleton instance = new Singleton();

     //提供一个共有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}

```

#### (2).静态代码块

> 优缺点和静态常量一致 
>
> 只不过初始化放到了静态代码块里

```java
package singleton.hungry;

/**
 * 单例模式 饿汉式（静态代码块）
 * @author 孙术强
 * @date 2021/2/4 14:51
 */
public class StaticBlock {
    public static void main(String[] args) {
        Singleton02 singleton1 = Singleton02.getInstance();
        Singleton02 singleton2 = Singleton02.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton02{
    private final static Singleton02 instance;
    private int a;
    //构造器私有化 外部不能new
    private  Singleton02(){

    }
    //在静态代码块中创建对象
    static {
        instance = new Singleton02();
    }
    //本类内部创建对象


    //提供一个共有的静态方法，返回实例对象
    public static Singleton02 getInstance() {
        return instance;
    }
}


```

### 2.懒汉式

> 是懒加载

#### (1).线程不安全(不能用)

> 在多个线程中，如果两个线程同时进入了
>
> if(instance==null){
>             instance = new Singleton01();
>  }
>
> 就会产生多个实例  所以不建议使用

```java
package singleton.lazy;

/**
 * 饿汉式（线程不安全）
 * @author 孙术强
 * @date 2021/2/4 15:04
 */
public class ThreadUnsafe {
    public static void main(String[] args) {
        Singleton01 singleton1 = Singleton01.getInstance();
        Singleton01 singleton2 = Singleton01.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton01{
    private static Singleton01 instance;
    
    //构造器私有化 外部不能new
    private  Singleton01(){

    }

    

    //在使用到该对象时才创建对象
    public static Singleton01 getInstance() {
        if(instance==null){
            instance = new Singleton01();
        }
        return instance;
    }
}

```

#### (2).静态代码块(不能用)

> 仍旧是线程不安全的

```java
package singleton.lazy;

/**
 * 饿汉式（静态代码块）
 * @author 孙术强
 * @date 2021/2/4 15:14
 */
public class StaticBlock {
    public static void main(String[] args) {
        Singleton02 singleton1 = Singleton02.getInstance();
        Singleton02 singleton2 = Singleton02.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton02{
    private final static Singleton02 instance;

    private Singleton02(){

    }
    static {
        instance = new Singleton02();
    }

    public static Singleton02 getInstance(){
        return instance;
    }
}


```

#### (3).线程安全(不推荐 性能低下)

> **是否 Lazy 初始化：**是
>
> **是否多线程安全：**是
>
> **实现难度：**易

> 对get方法加锁处理 但是执行get方法时都要进行同步  所以性能低下

```java
package singleton.lazy;


/**
 * 饿汉式（线程安全）
 * @author 孙术强
 * @date 2021/2/4 15:24
 */
public class ThreadSafe {
    public static void main(String[] args) {
        Singleton03 singleton1 = Singleton03.getInstance();
        Singleton03 singleton2 = Singleton03.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton03{
    private static Singleton03 instance;
    private Singleton03 (){}
    //进行加锁处理使线程安全
    public static synchronized Singleton03 getInstance() {
        if (instance == null) {
            instance = new Singleton03();
        }
        return instance;
    }
}

```

#### (4).双检锁/双重校验锁（推荐）

> **JDK 版本：**JDK1.5 起
>
> **是否 Lazy 初始化：**是
>
> **是否多线程安全：**是
>
> **实现难度：**较复杂

> 推荐 高性能

```java
package singleton.lazy;


/**
 * 饿汉式（双检锁/双重校验锁） 推荐
 * @author 孙术强
 * @date 2021/2/4 15:37
 */
public class DoubleThreadSafe {
    public static void main(String[] args) {
        Singleton04 singleton1 = Singleton04.getInstance();
        Singleton04 singleton2 = Singleton04.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}
class Singleton04{
    private static volatile Singleton04 instance;
    private Singleton04() {
        
    }
    //双重检查
    public static Singleton04 getInstance() {
        if(instance==null){
            synchronized (Singleton04.class){
                if (instance==null){
                    instance = new Singleton04();
                }
            }
        }
        return instance;
    }
}
```

### 3.静态内部类（推荐）

> **是否 Lazy 初始化：**是
>
> **是否多线程安全：**是
>
> **实现难度：**一般

> 线程安全 性能高 代码简单

```java
package singleton.staticinnerclass;


/**
 * 静态内部类 推荐使用
 * @author 孙术强
 * @date 2021/2/4 15:46
 */
public class StaticInner {
    public static void main(String[] args) {
        Singleton Singleton041 = Singleton.getInstance();
        Singleton Singleton042 = Singleton.getInstance();
        System.out.println(Singleton041 == Singleton042);
        System.out.println(Singleton041.hashCode() == Singleton042.hashCode());
    }
}

class Singleton{
    private static class Singleton04Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton (){}
    public static final Singleton getInstance() {
        return Singleton04Holder.INSTANCE;
    }
}

```

### 4.枚举（推荐）

> **JDK 版本：**JDK1.5 起
>
> **是否 Lazy 初始化：**否
>
> **是否多线程安全：**是
>
> **实现难度：**易

> 涉及到反序列化创建对象时 建议使用

```java
package singleton._enum;

/**
 * 单例模式 枚举实现
 * @author 孙术强
 * @date 2021/2/4 15:52
 */
public class Enum {
    public static void main(String[] args) {
        Singleton singleton = Singleton.INSTANCE;
        Singleton singleton1 = Singleton.INSTANCE;
        System.out.println(singleton==singleton1);
        System.out.println(singleton.hashCode()==singleton1.hashCode());
    }
}

enum Singleton{
    INSTANCE;
}
```


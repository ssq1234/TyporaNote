# 设计模式

## 一.单例模式

> **意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。
>
> **主要解决：**一个全局使用的类频繁地创建与销毁。
>
> **何时使用：**当您想控制实例数目，节省系统资源的时候

### 1.饿汉式(推荐 但可能会造成内存浪费)

> **是否 Lazy 初始化：**否
>
> **是否多线程安全：**是
>
> **实现难度：**易

> 不是懒加载 在类装载时就完成了初始化

#### (1).静态常量

> 在类装载时就完成了初始化 避免了线程同步问题
>
> 但是没有达到懒加载的目的 可能会造成内存浪费

```java
package singleton.hungry;

/**
 * 单例模式 饿汉式（静态常量）
 * @author 孙术强
 * @date 2021/2/4 14:38
 */
public class StaticFinal {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}



class Singleton{

     //构造器私有化 外部不能new
    private  Singleton(){

    }

     //本类内部创建对象
    private final static Singleton instance = new Singleton();

     //提供一个共有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}

```

#### (2).静态代码块

> 优缺点和静态常量一致 
>
> 只不过初始化放到了静态代码块里

```java
package singleton.hungry;

/**
 * 单例模式 饿汉式（静态代码块）
 * @author 孙术强
 * @date 2021/2/4 14:51
 */
public class StaticBlock {
    public static void main(String[] args) {
        Singleton02 singleton1 = Singleton02.getInstance();
        Singleton02 singleton2 = Singleton02.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton02{
    private final static Singleton02 instance;
    private int a;
    //构造器私有化 外部不能new
    private  Singleton02(){

    }
    //在静态代码块中创建对象
    static {
        instance = new Singleton02();
    }
    //本类内部创建对象


    //提供一个共有的静态方法，返回实例对象
    public static Singleton02 getInstance() {
        return instance;
    }
}


```

### 2.懒汉式

> 是懒加载

#### (1).线程不安全(不能用)

> 在多个线程中，如果两个线程同时进入了
>
> if(instance==null){
>             instance = new Singleton01();
>  }
>
> 就会产生多个实例  所以不建议使用

```java
package singleton.lazy;

/**
 * 饿汉式（线程不安全）
 * @author 孙术强
 * @date 2021/2/4 15:04
 */
public class ThreadUnsafe {
    public static void main(String[] args) {
        Singleton01 singleton1 = Singleton01.getInstance();
        Singleton01 singleton2 = Singleton01.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton01{
    private static Singleton01 instance;
    
    //构造器私有化 外部不能new
    private  Singleton01(){

    }

    

    //在使用到该对象时才创建对象
    public static Singleton01 getInstance() {
        if(instance==null){
            instance = new Singleton01();
        }
        return instance;
    }
}

```

#### (2).静态代码块(不能用)

> 仍旧是线程不安全的

```java
package singleton.lazy;

/**
 * 饿汉式（静态代码块）
 * @author 孙术强
 * @date 2021/2/4 15:14
 */
public class StaticBlock {
    public static void main(String[] args) {
        Singleton02 singleton1 = Singleton02.getInstance();
        Singleton02 singleton2 = Singleton02.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton02{
    private final static Singleton02 instance;

    private Singleton02(){

    }
    static {
        instance = new Singleton02();
    }

    public static Singleton02 getInstance(){
        return instance;
    }
}


```

#### (3).线程安全(不推荐 性能低下)

> **是否 Lazy 初始化：**是
>
> **是否多线程安全：**是
>
> **实现难度：**易

> 对get方法加锁处理 但是执行get方法时都要进行同步  所以性能低下

```java
package singleton.lazy;


/**
 * 饿汉式（线程安全）
 * @author 孙术强
 * @date 2021/2/4 15:24
 */
public class ThreadSafe {
    public static void main(String[] args) {
        Singleton03 singleton1 = Singleton03.getInstance();
        Singleton03 singleton2 = Singleton03.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}

class Singleton03{
    private static Singleton03 instance;
    private Singleton03 (){}
    //进行加锁处理使线程安全
    public static synchronized Singleton03 getInstance() {
        if (instance == null) {
            instance = new Singleton03();
        }
        return instance;
    }
}

```

#### (4).双检锁/双重校验锁（推荐）

> **JDK 版本：**JDK1.5 起
>
> **是否 Lazy 初始化：**是
>
> **是否多线程安全：**是
>
> **实现难度：**较复杂

> 推荐 高性能

```java
package singleton.lazy;


/**
 * 饿汉式（双检锁/双重校验锁） 推荐
 * @author 孙术强
 * @date 2021/2/4 15:37
 */
public class DoubleThreadSafe {
    public static void main(String[] args) {
        Singleton04 singleton1 = Singleton04.getInstance();
        Singleton04 singleton2 = Singleton04.getInstance();
        System.out.println(singleton1 == singleton2);
        System.out.println(singleton1.hashCode() == singleton2.hashCode());
    }
}
class Singleton04{
    private static volatile Singleton04 instance;
    private Singleton04() {
        
    }
    //双重检查
    public static Singleton04 getInstance() {
        if(instance==null){
            synchronized (Singleton04.class){
                if (instance==null){
                    instance = new Singleton04();
                }
            }
        }
        return instance;
    }
}
```

### 3.静态内部类（推荐）

> **是否 Lazy 初始化：**是
>
> **是否多线程安全：**是
>
> **实现难度：**一般

> 线程安全 性能高 代码简单

```java
package singleton.staticinnerclass;


/**
 * 静态内部类 推荐使用
 * @author 孙术强
 * @date 2021/2/4 15:46
 */
public class StaticInner {
    public static void main(String[] args) {
        Singleton Singleton041 = Singleton.getInstance();
        Singleton Singleton042 = Singleton.getInstance();
        System.out.println(Singleton041 == Singleton042);
        System.out.println(Singleton041.hashCode() == Singleton042.hashCode());
    }
}

class Singleton{
    private static class Singleton04Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton (){}
    public static final Singleton getInstance() {
        return Singleton04Holder.INSTANCE;
    }
}

```

### 4.枚举（推荐）

> **JDK 版本：**JDK1.5 起
>
> **是否 Lazy 初始化：**否
>
> **是否多线程安全：**是
>
> **实现难度：**易

> 涉及到反序列化创建对象时 建议使用

```java
package singleton._enum;

/**
 * 单例模式 枚举实现
 * @author 孙术强
 * @date 2021/2/4 15:52
 */
public class Enum {
    public static void main(String[] args) {
        Singleton singleton = Singleton.INSTANCE;
        Singleton singleton1 = Singleton.INSTANCE;
        System.out.println(singleton==singleton1);
        System.out.println(singleton.hashCode()==singleton1.hashCode());
    }
}

enum Singleton{
    INSTANCE;
}
```

## 二.工厂模式

### 1.简单工厂模式

> 定义了一个创建对象的类，类中封装了实例化对象的行为

#### (1).反例

> 违反了设计模式的ocp原则，即对扩展开放，对修改关闭
>
> 当新增加一个Pizza的子类，就要对订单类OrderPizza进行修改,**违反了对修改关闭**

```java
package factory.simplefactory.bad.order;
/**
 * 发出订购
 * @author 孙术强
 * @date 2021/2/8 11:11
 */
public class PizzaStore {
    public static void main(String[] args) {
        new OrderPizza();
    }
}
```

```java
package factory.simplefactory.bad.order;

import factory.simplefactory.bad.pizza.CheessPizza;
import factory.simplefactory.bad.pizza.GreekPizza;
import factory.simplefactory.bad.pizza.Pizza;

/**
 * 订购pizza
 * @author 孙术强
 * @date 2021/2/8 11:03
 */
public class OrderPizza {
    //构造器
    public OrderPizza() {
        Pizza pizza = null;
        String orderType; //订购pizza的类型
        orderType = getType();
        if (orderType.equals("greek")) {
            pizza = new GreekPizza();
            pizza.setName("greek");
        } else if (orderType.equals("cheese")) {
            pizza = new CheessPizza();
            pizza.setName("cheese");
        }
        assert pizza != null;
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
    }
    //获取pizza种类
    private String getType() {
        return "cheese";
    }
}
```

```java
package factory.simplefactory.bad.pizza;
/**
 * pizza的父类
 * @author 孙术强
 * @date 2021/2/8 10:56
 */
public abstract class Pizza {
    protected String name; //名字
    public abstract void prepare(); //准备原材料 不同的pizza是不一样的 因此我们把它做成抽象方法
    //烘烤
    public void bake(){
        System.out.println(name+"baking;");
    }
    //切割
    public void cut(){
        System.out.println(name+"cutting;");
    }
    //打包
    public void box(){
        System.out.println(name+"boxing;");
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package factory.simplefactory.bad.pizza;
/**
 * cheesspizza
 * @author 孙术强
 * @date 2021/2/8 11:00
 */
public class CheessPizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println("给奶酪pizza，准备原材料");
    }
}
```

```java
package factory.simplefactory.bad.pizza;
/**
 * greekpizza
 * @author 孙术强
 * @date 2021/2/8 11:02
 */
public class GreekPizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println("给希腊pizza，准备原材料");
    }
}
```

#### (2).正确

> 创建一个工厂SimpleFactory来获取对象，如果徐要修改，只需要在工厂SimpleFactory修改

```java
package factory.simplefactory.good.order;
import factory.simplefactory.good.pizza.CheessPizza;
import factory.simplefactory.good.pizza.GreekPizza;
import factory.simplefactory.good.pizza.Pizza;
/**
 * 工厂模式  简单工厂模式
 * 工厂用来获取对象
 * @author 孙术强
 * @date 2021/2/8 10:51
 */
public class SimpleFactory {
    public Pizza createPizza(String orderType){
        Pizza pizza = null;
        if (orderType.equals("greek")) {
            pizza = new GreekPizza();
            pizza.setName("greek");
        } else if (orderType.equals("cheese")) {
            pizza = new CheessPizza();
            pizza.setName("cheese");
        }
        return pizza;
    }
}
```

```java
package factory.simplefactory.good.order;
/**
 * 工厂模式  简单工厂模式
 * 发出订购
 * @author 孙术强
 * @date 2021/2/8 11:11
 */
public class PizzaStore {
    public static void main(String[] args) {
        new OrderPizza().setSimpleFactory();
    }
}
```

```java
package factory.simplefactory.good.order;
import factory.simplefactory.good.pizza.Pizza;
/**
 * 工厂模式  简单工厂模式
 * 订购pizza
 * @author 孙术强
 * @date 2021/2/8 11:03
 */
public class OrderPizza {
    SimpleFactory simpleFactory =new SimpleFactory();
    Pizza pizza = null;
    public void setSimpleFactory() {
        String orderType = getType();
        pizza = simpleFactory.createPizza(orderType); //从工厂获取对象
        if (pizza!=null){
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        }
        else {
            System.out.println("没有该类型");
        }
    }
    //获取pizza种类
    private String getType() {
        return "paa";
    }
}
```

```java
package factory.simplefactory.good.pizza;
/**
 * 工厂模式  简单工厂模式
 * pizza的父类
 * @author 孙术强
 * @date 2021/2/8 10:56
 */
public abstract class Pizza {
    protected String name; //名字
    public abstract void prepare(); //准备原材料 不同的pizza是不一样的 因此我们把它做成抽象方法
    //烘烤
    public void bake(){
        System.out.println(name+"baking;");
    }
    //切割
    public void cut(){
        System.out.println(name+"cutting;");
    }
    //打包
    public void box(){
        System.out.println(name+"boxing;");
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package factory.simplefactory.good.pizza;
/**
 * 工厂模式  简单工厂模式
 * pizza的父类
 * @author 孙术强
 * @date 2021/2/8 10:56
 */
public abstract class Pizza {
    protected String name; //名字
    public abstract void prepare(); //准备原材料 不同的pizza是不一样的 因此我们把它做成抽象方法
    //烘烤
    public void bake(){
        System.out.println(name+"baking;");
    }
    //切割
    public void cut(){
        System.out.println(name+"cutting;");
    }
    //打包
    public void box(){
        System.out.println(name+"boxing;");
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package factory.simplefactory.good.pizza;
/**
 * 工厂模式  简单工厂模式
 * cheesspizza
 * @author 孙术强
 * @date 2021/2/8 11:00
 */
public class CheessPizza extends Pizza {
    @Override
    public void prepare() {
        System.out.println("给奶酪pizza，准备原材料");
    }
}
```

```java
package factory.simplefactory.good.pizza;
/**
 * 工厂模式  简单工厂模式
 * greekpizza
 * @author 孙术强
 * @date 2021/2/8 11:02
 */
public class GreekPizza extends Pizza {
    @Override
    public void prepare() {
        System.out.println("给希腊pizza，准备原材料");
    }
}
```

### 2.工厂方法模式